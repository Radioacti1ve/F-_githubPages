<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xpyc documentation</title>
    <link rel="stylesheet" href="fonts/fonts.css">
    <link rel="stylesheet" href="styles/style.css">
</head>
<body>
    <div class="documentation">
        <h2 class="logo">XpycTeam</h2>
        <h1 class="title main-title">Приёмы функционального программирования, как мы их использовали при выполнении курсовой, и как будем использовать в дальнейшей жизни</h1>
        
        <div class="documentationwrapper">
            <p class="First_p">Существует множество функциональных языков программирования, у каждого из них есть свои плюсы и минусы. При написании лабораторной работы, мы использовали мультипарадигмальный язык программирования из семейства языков .NET - F#. Среди его достоинств можно выделить следующие:<br></p>
        </div>
        <ol class="list">
          <li class="list-item">Безопасность типов: Код на F# безопасен в отношении типов и часто бывает более компактным, чем аналогичный код на C#;</li>
          <li class="list-item">Неявные преобразования типов отсутствуют: F# не допускает неявных преобразований типов, что исключает ошибки, связанные с приведением типов;</li>
          <li class="list-item">Функции высших порядков и обобщённое программирование: F# позволяет писать абстрактные обобщенные алгоритмы, управляющие параметризованными структурами данных;</li>
          <li class="list-item">Константные значения по умолчанию: В F# все значения по умолчанию являются константами. Однако можно использовать изменяемые значения с помощью ключевого слова mutable;</li>
          <li class="list-item">Чистые функции и упрощенное параллелирование: Большая часть кода в F# — это чистые функции, что упрощает отладку и распараллеливание программ.</li>
        </ol>
       
        <div class="documentationwrapper">
            <p>Язык F# предлагает широкий спектр возможностей для реализации функциональных приемов в программировании. В рамках курсовой я продемонстрирую и расскажу про часть из них.<br></p>
        </div>
        <h2 class="title">
            Функции высшего порядка
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">Функции высшего порядка (Higher-Order Functions) - это функции, которые могут принимать другие функции в качестве аргументов и/или возвращать функции в качестве результата. Они являются одним из ключевых концептов функционального программирования. В рамках лабораторной работы, при реализации интерпретатора подобный пример реализован в функции funof.Функции высшего порядка (Higher-Order Functions) - это функции, которые могут принимать другие функции в качестве аргументов и/или возвращать функции в качестве результата. Они являются одним из ключевых концептов функционального программирования. В рамках лабораторной работы, при реализации интерпретатора подобный пример реализован в функции funof.<br><br> Пример из кода:<br></p>
        </div>
        <div class="codewrapper">
            <code>
            let funof = function <br>
            &nbsp| "+" -> <br>
            &nbsp&nbsp(function <br>
            &nbsp&nbsp&nbsp| [Int(a); Int(b)] -> Int(a+b)<br>
            &nbsp&nbsp&nbsp| _ -> failwith "Invalid arguments for +"<br>
            &nbsp&nbsp)
            </code>
        </div>
        <h2 class="title">
            Рекурсии
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">В функциональном программировании рекурсия часто используется вместо циклов. Функции вызывают сами себя, чтобы решить подзадачи. Функция eval рекурсивно вычисляет выражения. Рекурсия используется вместо циклов для обработки структур данных и выполнения повторяющихся задач. Также рекурсивно реализованы функции evalFor и evalFunction.<br>
               <br> Примеры рекурсий на F#:
                </p>
        </div>
        <div class="codewrapper">
            <code>
            let rec factorial n =
                if n = 0 then 1
                else n * factorial (n - 1)

            // Пример использования
            let result = factorial 5 // результат: 120
            </code>
        </div>
        <h2 class="title">
            Хвостовая рекурсия
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">Хвостовая рекурсия - это специальный вид рекурсии, при котором рекурсивный вызов функции является последней операцией в функции. Это позволяет компилятору оптимизировать код и избежать переполнения стека, заменяя рекурсивные вызовы на итеративный цикл. В F# хвостовая рекурсия особенно важна, так как компилятор поддерживает оптимизацию хвостовой рекурсии (Tail Call Optimization), которая позволяет использовать рекурсию для обработки больших данных без опасения переполнения стека. В коде интерпретатора данный прием представлен  функциями evalFunction и evalFor, реализованы с использованием хвостовой рекурсии для оптимизации и предотвращения переполнения стека.<br>
                <br>Пример кода:
                <br></p>
        </div>
        <div class="codewrapper">
            <code>
            and evalFunction(body: Expr list, env: Map<Id, Expr>): Expr * Map<Id, Expr> =
                match body with
                | [] -> (Nothing, env)
                | expr::tail ->
                    let (ex, newEnv) = eval(expr, env)
                    match ex with
                    | Return(value) -> (value, env)
                    | _ -> evalFunction(tail, newEnv) 

            </code>
        </div>
        <h2 class="title">
            Замыкания
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">Замыкание (closure) в функциональном программировании - это функция, которая захватывает свое лексическое окружение в момент своего создания. Другими словами, замыкание содержит не только код функции, но и ссылку на окружение, в котором оно было определено. Это позволяет замыканию обращаться к переменным и параметрам из своего внешнего контекста, даже после того, как контекст, в котором оно было создано, вышел из области видимости.
                В F# замыкания очень распространены, поскольку они играют ключевую роль в функциональном стиле программирования. Вот пример создания и использования замыкания, использованные при создании парсера:                
                <br></p>
        </div>
        <div class="codewrapper">
            <code>
            and letParser : Parser<Expr, unit> =
                pipe2
                    (pstring "let" .>> spaces >>. identifierParser)
                    (pchar '=' .>> spaces >>. exprParser)
                    (fun varName expr -> Let(varName, expr))
            Пример при создании интерпретатора:
            let funof = function
                | "+" -> 
                    (function 
                        | [Int(a); Int(b)] -> Int(a+b)
                        | _ -> failwith "Invalid arguments for +"
                    )
                | "-" -> 
                    (function 
                        | [Int(a); Int(b)] -> Int(a-b)
                        | _ -> failwith "Invalid arguments for -"
                    )
                | _ -> failwith "Unknown operation"

            </code>
        </div>
        <h2 class="title">
            Чистые функции (pure functions)
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">Чистая функция в функциональном программировании — это функция, которая:</p>
        </div>
        <ol class="list">
          <li class="list-item">Возвращает результат: У чистой функции всегда есть возвращаемое значение. Она не изменяет состояние программы напрямую</li>
          <li class="list-item">Детерминирована: Для одинаковых входных данных чистая функция всегда возвращает одинаковый результат</li>
          <li class="list-item">Нет побочных эффектов: Чистая функция не изменяет состояние программы вне своего контекста. Она не изменяет внешние переменные, не делает записи в файлы, не взаимодействует с сетью и так далее</li>
        </ol>
        <div class="documentationwrapper">
            <p>В лабораторной работе данный прием представлен функцией Print и Read_int.              
                <br></p>
        </div>
        <h2 class="title">
            Ленивые вычисления
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">Ленивые вычисления (lazy evaluation) — это стратегия вычислений, при которой вычисление выражения откладывается до тех пор, пока его значение действительно не понадобится.
                <br>
                Преимущества ленивых вычислений:
                <br>
            </p>
        </div>
        <ol class="list">
          <li class="list-item">Экономия ресурсов: Вычисления происходят только в случае реальной необходимости, что позволяет избежать излишних расходов памяти и процессорного времени</li>
          <li class="list-item">Бесконечные структуры данных: Ленивые вычисления позволяют работать с бесконечными или потенциально бесконечными структурами данных, такими как потоки (streams) или бесконечные списки</li>
          <li class="list-item">Увеличение производительности: В некоторых случаях ленивые вычисления могут сделать программу более производительной за счет отсроченных вычислений.</li>
        </ol>
       
        <div class="documentationwrapper">
            <p>В лабораторной работе данный прием представлен функцией Print и Read_int.              
                <br>
                Пример ленивых вычислений на F#:
                <br>
            </p>
        </div>
        <div class="codewrapper">
            <code>
            let rec factorial n =
                if n = 0 then 1
                else n * factorial (n - 1)
            
            let rec factorialLazy n =
                seq { yield 1
                      for i in 1 .. n do
                          yield i * Seq.nth (Seq.init i id) (i - 1) } |> Seq.nth (n-1)
            
            let result = factorial 5
            let resultLazy = factorialLazy 5
            </code>
        </div>
        <h2 class="title">
            Лямбда-функции
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">В F# лямбда-функции представляются с помощью ключевого слова fun. Они могут быть использованы для создания анонимных функций, которые могут быть переданы в функции высшего порядка или использованы в качестве локальных функций.
            </p>
        </div>
        <div class="codewrapper">
            <code>
            // Пример лямбда-функции для вычисления квадрата числа
            let square = fun x -> x * x

            // Использование лямбда-функции
            printfn "%d" (square 5) // Вывод: 25

            // Пример использования лямбда-функции в функции высшего порядка
            let numbers = [1; 2; 3; 4; 5]
            let squares = List.map (fun x -> x * x) numbers
            </code>
        </div>
        <h2 class="title">
            Как мы будем использовать приемы функционального программирования в дальнейшем
        </h2>
        <div class="documentationwrapper">
            <p class="First_p">Функциональные приемы универсальны. Их применение не ограничивается функциональными языками программирования. Некоторые давно перетекли в императивные языки программирования. Множество приемов и концепций из функциональных языков программирования были заимствованы и интегрированы в императивные языки. Вот некоторые из них:
                <br>
            </p>
        </div>
        <ol class="list">
          <li class="list-item">Лямбда-функции: Использование анонимных функций (лямбда-функций) было заимствовано из
            функциональных языков и внедрено во многие императивные языки, такие как Python, Java, C# и другие</li>
          <li class="list-item">Функции высших порядков: Возможность передавать функции как аргументы и возвращать их из других
            функций также стала распространенной практикой в императивных языках. Это позволяет писать более компактный и
            выразительный код</li>
          <li class="list-item">Неизменяемость данных: Концепция неизменяемости данных, где данные не могут быть изменены после
            создания, была заимствована из функциональных языков и интегрирована в некоторые императивные языки. Например, в
            Java неизменяемые объекты могут быть созданы с помощью ключевого слова final</li>
          <li class="list-item">Рекурсия: Хотя рекурсия в основном ассоциируется с функциональным программированием, многие
            императивные языки также поддерживают рекурсию в своих функциональных частях</li>
          <li class="list-item">Композиция функций: Возможность объединять функции в цепочку, называемую композицией функций,
            стала доступной и в некоторых императивных языках. Это позволяет писать более элегантный и выразительный код.</li>
          <li class="list-item">Функциональные типы данных: Некоторые императивные языки включают в себя структуры данных, такие
            как списки, карты (ассоциативные массивы), и т.д., которые имеют функциональные свойства, такие как неизменяемость.
          </li>
        </ol>
        <div class="documentationwrapper">
            <p>Дальнейшее развитие функциональных языков ведет к неизбежному созданию новых приемов, которые, в свою очередь, распространятся дальше.  Сфера применения функциональных языков не ограничена, поэтому появление новых приемов неизбежно.
                <br>
            </p>
        </div>
    </div>
</body>
</html>